import * as fs from 'fs';
import * as path from 'path';

const snakeToPascal = text =>
  text
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');

const snakeToCamel = text => {
  const pascal = snakeToPascal(text);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
};

// Value accessors for form elements are needed to integrate custom elements with Angular Forms. Without these, Angular Forms won't be able to read and write values to the custom elements.
const getFormElementAccessor = (tagName, angularSelector) => {
  const accessorName = `${snakeToPascal(tagName)}ValueAccessor`;

  switch (tagName) {
    case 'fhi-button':
      break;
    case 'fhi-text-input':
    case 'fhi-date-input':
      return {
        accessorName,
        accessorImports: ['NG_VALUE_ACCESSOR', 'DefaultValueAccessor'],
        accessor: `
          @Directive({ selector: '${angularSelector}[formControlName],${angularSelector}[formControl],${angularSelector}[ngModel]', standalone: true, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ${accessorName}), multi: true }] })
          export class ${accessorName} extends DefaultValueAccessor {}
          `,
      };
    case 'fhi-checkbox':
      return {
        accessorName,
        accessorImports: ['NG_VALUE_ACCESSOR', 'CheckboxControlValueAccessor'],
        accessor: `
          @Directive({ selector: '${angularSelector}[formControlName],${angularSelector}[formControl],${angularSelector}[ngModel]', standalone: true, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ${accessorName}), multi: true }] })
          export class ${accessorName} extends CheckboxControlValueAccessor {}
          `,
      };
    case 'fhi-radio':
      return {
        accessorName,
        accessorImports: ['NG_VALUE_ACCESSOR', 'RadioControlValueAccessor'],
        accessor: `
          @Directive({ selector: '${angularSelector}[formControlName],${angularSelector}[formControl],${angularSelector}[ngModel]', standalone: true, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ${accessorName}), multi: true }] })
          export class ${accessorName} extends RadioControlValueAccessor {}
          `,
      };
    default:
      throw new Error(`No form value accessor found for tagName ${tagName}.`);
      break;
  }
};

const isOptionalAttribute = attribute =>
  attribute.type.text.includes('undefined') || attribute.default !== undefined;

const main = ({ manifestPath, outputPath }) => {
  const indexTsFile = [];

  if (!manifestPath) {
    console.error(
      'Please provide the --manifest argument with the path to the custom element manifest file.',
    );
    process.exit(1);
  }

  if (!outputPath) {
    console.error(
      'Please provide the --output argument with the path to the output directory.',
    );
    process.exit(1);
  }

  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath, { recursive: true });
  }

  const folderContent = fs.readdirSync(outputPath);

  if (folderContent.length > 0) {
    const folderContent = fs.readdirSync(outputPath);

    folderContent.forEach(file => {
      const filePath = path.join(outputPath, file);
      if (fs.lstatSync(filePath).isFile()) {
        fs.unlinkSync(filePath);
      }
    });
  }

  let manifest;
  try {
    manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
  } catch (error) {
    console.error('Error reading manifest file:', error);
  }

  manifest.modules.forEach(module => {
    const componentClass = module.declarations.find(
      declaration => declaration.kind === 'class',
    );

    if (!componentClass || !componentClass.customElement) {
      return;
    }

    const className = componentClass.name;
    const tagName = componentClass.tagName;
    const attributes = componentClass.attributes || [];
    const events = componentClass.events || [];
    const slots = componentClass.slots || [];
    const isFormAssociated = componentClass.members.some(
      member => member.name === 'formAssociated',
    );

    if (!tagName) {
      throw new Error(`No tagName found for component class ${className}`);
    }

    const angularSelector = tagName.split('fhi-').join('fhi-ng-');

    const accessorInfo = isFormAssociated
      ? getFormElementAccessor(tagName, angularSelector)
      : null;

    const template = `
      /** This file is autogenerated. Do not edit directly. **/
      import { Component${attributes.length > 0 ? ', Input' : ''}${events.length > 0 ? ', Output, EventEmitter' : ''}${accessorInfo ? `, Directive, forwardRef` : ''}, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';

      import '../${tagName}';
      
      ${accessorInfo ? `import { ${accessorInfo.accessorImports.join(', ')} } from '@angular/forms';` : ''}
      
      ${accessorInfo?.accessor ?? ''}

      @Component({
        selector: '${angularSelector}',
        schemas: [CUSTOM_ELEMENTS_SCHEMA],
        standalone: true,
        template: ${`\`
            <${tagName}
              ${attributes.map(attribute => `[${attribute.fieldName}]="${attribute.fieldName}"`).join(' ')}
              ${events.map(event => `(${event.name})="handle${snakeToPascal(event.name)}($event)"`).join(' ')}
            >
              ${slots.map(slot => `<ng-content ${slot.name ? `select="[slot='${slot.name}']"` : ''}></ng-content>`).join('\n')}
            </${tagName}>
          \``},
      })
      export class ${className}AngularWrapper {
        ${attributes
          .map(
            attribute => `
            /** ${attribute.description || ''} */
            @Input({alias: "${attribute.name}", required: ${!isOptionalAttribute(attribute)}}) ${attribute.fieldName}${isOptionalAttribute(attribute) ? '?' : '!'}: ${`${attribute.parsedType?.text ?? attribute.type.text}` || 'string'}${
              attribute.default ? ` = ${attribute.default}` : ''
            };
        `,
          )
          .join('')}

        ${events
          .map(
            event => `
            /** ${event.description || ''} */
            @Output("${event.name}") ${snakeToCamel(event.name)} = new EventEmitter<Event>();
            handle${snakeToPascal(event.name)}(event: Event) {
              event.stopPropagation();
              this.${snakeToCamel(event.name)}.emit(event);
            }
        `,
          )
          .join('')}
      }
    `;

    fs.writeFileSync(
      `${path.join(outputPath, `${tagName}.component.ts`)}`,
      template,
      'utf8',
    );

    indexTsFile.push(`export * from './${tagName}.component';`);
  });

  fs.writeFileSync(
    path.join(outputPath, 'index.ts'),
    indexTsFile.join('\n'),
    'utf8',
  );

  console.log(
    `Successfully generated ${indexTsFile.length} Angular wrappers to ${outputPath}`,
  );
};

main({
  manifestPath:
    process.argv.indexOf('--manifest') !== -1
      ? process.argv[process.argv.indexOf('--manifest') + 1]
      : undefined,
  outputPath:
    process.argv.indexOf('--output') !== -1
      ? process.argv[process.argv.indexOf('--output') + 1]
      : undefined,
});
